Type casting - 

1. Date Manipulation
   - Question: Retrieve the rental dates from the rental table and convert them to a custom date format. Then, group the rentals by month and calculate the total revenue for each month.

	SELECT CONCAT('Total Revenue is ', SUM(pay.amount), ' in ', format(rent.rental_date, 'MMMM')) AS Total_Revenue
	FROM rental AS rent
	INNER JOIN
	payment AS pay
	ON rent.rental_id = pay.rental_id
	GROUP BY FORMAT(rent.rental_date, 'MMMM')
	
2. Complex Data Conversion
   - Question: In the customer table, extract the domain names from the email addresses and convert them to uppercase. Return the distinct domain names along with the count of customers having emails from each domain.

	SELECT UPPER(SUBSTRING(email, CHARINDEX('@', email) , LEN(email))) AS domain, COUNT(*) AS total_customer
	FROM customer
	GROUP BY SUBSTRING(email, CHARINDEX('@', email), LEN(email))

3. Handling Invalid Data
   - Question: Parse the description column from the film table as integers. For any descriptions that cannot be parsed as integers, truncate them and append '... (truncated)'. Display the modified descriptions along with the film titles.

	SELECT title,
	CASE 
		WHEN TRY_PARSE(CAST(description AS VARCHAR(MAX)) AS INT) IS NOT NULL THEN description
		ELSE LEFT(CAST(description AS VARCHAR(MAX)), 10) + '... (truncated)'
	END AS modified_description
	FROM film;

4. Conditional Conversions
   - Question: Convert the postal_code column from the address table to integers. If the conversion fails, set the value to 0. Then, calculate the average postal code value for each city and display the result along with the city names.

	SELECT ct.city AS city_name, avg(isnull(try_cast(postal_code as int),0)) AS average_postal_code, adr.city_id
	FROM address adr
	INNER JOIN city ct
	ON adr.city_id = ct.city_id
	GROUP BY adr.city_id, ct.city;

5. Multi-step Conversion
   - Question: Convert the special_features column from the film table to a binary representation where each feature is represented by a bit. Handle null values gracefully. Then, aggregate the binary representations to count the occurrence of each feature across all films.

	WITH FeaturesName AS (
		SELECT film_id, special_features,
		CAST(
		CASE
			WHEN special_features LIKE '%Trailers%' AND special_features IS NOT NULL THEN 1
			ELSE 0	
		END AS BIT) AS Trailers,
		CAST(
		CASE
			WHEN special_features LIKE '%Deleted Scenes%' AND special_features IS NOT NULL THEN 1
			ELSE 0
		END AS bit) AS Deleted_scenes,
		CAST(
		CASE
			WHEN special_features LIKE '%Behind the Scenes%' AND special_features IS NOT NULL THEN 1
			ELSE 0
		END AS bit) AS Behind_the_scenes,
		CAST(
		CASE
			WHEN special_features LIKE '%Commentaries%' AND special_features IS NOT NULL THEN 1
			ELSE 0
		END AS bit) AS Commentaries
	    FROM film
	)
    
	SELECT SUM(CAST(Trailers AS int)) AS Count_of_Trailers, SUM(CAST(Deleted_scenes AS int)) AS Count_of_Deleted_Scenes, SUM(CAST(Behind_the_scenes AS int)) AS Count_of_Behind_the_scenes, SUM(CAST(Commentaries AS int)) AS Count_of_Commentaries
	FROM FeaturesName

handling Null and fetch and offset - 

1. Advanced Query 1: Conditional Aggregation
   - Question: Calculate the average rental duration for each film category. If the average rental duration is null, replace it with the overall average rental duration for all films.

	SELECT COALESCE(flm.category, 'Total') AS category, AVG(DATEDIFF(DAY, rent.rental_date, rent.return_date)) AS rental_duration
    	FROM rental rent 
    	INNER JOIN inventory inv
	ON rent.inventory_id = inv.inventory_id 
    	INNER JOIN film_list flm
	ON inv.film_id = flm.FID 
    	GROUP BY ROLLUP(flm.category)

2. **Advanced Query 2: Dynamic Pagination**
   - Question: Implement dynamic pagination for retrieving customer records from the customer table. Allow users to specify the page number and the number of records per page.

	DECLARE @PageNumber INT = 5; 
	DECLARE @PageSize INT = 152; 

	SELECT customer_id,first_name,last_name,email
	FROM customer
	ORDER BY customer_id
	OFFSET (@PageNumber - 1) ROWS
	FETCH NEXT @PageSize ROWS ONLY;

3. **Advanced Query 5: Conditional Ordering**
   - Question: Retrieve the top 10 customers based on their total payments. If two customers have the same total payment, order them alphabetically by their last names.
	
	

Group By Types - 

**Medium Level:**

1. Grouping Sets
   - Question: Calculate the total revenue generated by each store, grouping by store ID. Additionally, provide the total revenue across all stores.

	SELECT ISNULL(STR(cust.store_id), 'Total') AS Store_ID, SUM(pay.amount) AS Total_Amount
	FROM customer AS cust
	INNER JOIN
	payment AS pay
	ON cust.customer_id = pay.customer_id
	GROUP BY ROLLUP (cust.store_id)	

2. Rollup
   - Question: Determine the count of rentals for each combination of customer and film category. Include the total count of rentals for each customer and the overall count for each film category.

	
	SELECT rent.customer_id, flm.category, COUNT(rent.inventory_id) AS count_of_rentals 
	FROM rental rent 
	INNER JOIN inventory inv
	ON rent.inventory_id = inv.inventory_id 
	INNER JOIN film_list flm
	ON inv.film_id = flm.FID 
	GROUP BY GROUPING SETS (
		(rent.customer_id, flm.category),
		(rent.customer_id),
		(flm.category),
		()
	)
	ORDER BY GROUPING(rent.customer_id), GROUPING(flm.category);

3. Cube
   - Question: Generate a report showing the total payments received per month, broken down by store, film category, and customer country. Include the grand total payment across all months, stores, categories, and countries.

	WITH payment_month AS (
    		SELECT customer_id, rental_id, amount, DATENAME(MONTH, payment_date) AS month_name
    		FROM payment
	)

	SELECT pay.month_name, cust.ID AS customer_id, flm.category, cust.SID AS store_id, SUM(pay.amount) AS total_amount
	FROM payment_month pay
	INNER JOIN customer_list cust
	ON pay.customer_id = cust.ID
	INNER JOIN rental rent
	ON pay.rental_id = rent.rental_id
	INNER JOIN inventory inv
	ON inv.inventory_id = rent.inventory_id
	INNER JOIN film_list flm
	ON inv.film_id = flm.FID
	GROUP BY GROUPING SETS (
       		(pay.month_name, cust.ID, flm.category, cust.SID),
        	(pay.month_name),
        	(cust.ID),
        	(flm.category),
        	(cust.SID),
        	()
	)
	ORDER BY GROUPING(pay.month_name), GROUPING(cust.ID), GROUPING(flm.category), GROUPING(cust.SID);

4. **Advanced Query 2: Grouping Sets**
   - Question: Calculate the average rental duration for each film category, store, and customer city. Include the overall average rental duration. Handle null values appropriately.

	select flm.category,cust.SID,cust.city, AVG(DATEDIFF(day,rent.rental_date,rent.return_date)) as Avg_Rental_Duration
	from film_list flm
	inner join inventory inv
	on flm.FID = inv.film_id
	inner join rental rent
	on inv.inventory_id = rent.inventory_id
	inner join customer_list cust
	on rent.customer_id = cust.ID
	group by GROUPING sets ((flm.category),(cust.SID),(cust.city),())
	order by GROUPING(flm.category),GROUPING(cust.SID),GROUPING(cust.city);	

Date and Time - 

1. **Advanced Query 1: Date Arithmetic**
   - Question: Calculate the average rental duration for each film category, considering only rentals that occurred during weekends (Saturday and Sunday). Exclude rentals with a duration longer than 3 days.

	with Weekends as (
		select inventory_id,AVG(DATEDIFF(day,rental_date,return_date)) as avg_duration
		from rental
		where DATENAME(WEEKDAY, rental_date) in ('Sunday','Saturday')
		group by inventory_id
		having AVG(DATEDIFF(day,rental_date,return_date)) <= 3
	)

	select flm.category,wik.avg_duration
	from film_list flm
	inner join inventory inv
	on flm.FID = inv.film_id
	inner join Weekends wik
	on wik.inventory_id = inv.inventory_id
	order by flm.category
